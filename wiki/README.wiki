#summary Overview and installation

= Introduction =

The most notorious type of bugs are thread interleaving dependent bugs; they are very hard to diagnose and reproduce. 

Many bug detection tools have been developed to detect those interleaving bugs for the last few years. While they are generally useful, they can not guarantee all interleaving bugs are identified simply because there are too many possible interleavings -- for example, a program with 10 threads each with 1 instruction have 10! interleavings.  

dpthread is a deterministic alternative of standard pthread. We call a program execution is deterministic, iff its correctness only depends on the input (does not depend on the thread interleaving order). 

The key idea of dpthread is the same as Kendo (ASPLOS09): determine the global order of all synchronization accesses based on instruction count. The goal is, however, different in a sense that we target to more general purpose multi-threaded application while Kendo primarily focus on parallel applications. Also, dpthread is very easy to use because it is built on top of standard pthread runtime and perf_event (linux kernel interface to access performance counter h/w. 

= Installation =

Dpthread is currently only tested on Intel Core2 processors. We use inst_retired:stores event of Core2 processors and it is the only deterministic event on Core2 processor as far as we know. Supporting other processors is straight forward if the processor have a deterministic counter. 

Dpthread use libpfm4 library to access performance counters. You can download it from http://perfmon2.sourceforge.net. 

Once you install the libpfm4, type 'make' on the top directory of dpthread. If the build succeed, you will see lib/libdpthread.a in lib/ directory. 

{{{
$ make 
Compiling for 'i686' target
make[1]: Entering directory `/home/heechul/Projects/dpthread/src'
sh -c ./detect_cpus.sh 
...
cp -a libdpthread.a ../lib
make[1]: Leaving directory `/home/heechul/Projects/dpthread/src'
}}}

Then, you can check whether it works correctly by doing the following. 

{{{
$ make check 
...
ITERATION 9
>> compare log8.p0 vs log9.p0
>> compare log8.p1 vs log9.p1
 -> OK
PASS 
}}}


= Run =

Let's look at a simple example to illustrate the benefits of using dpthread. 
In deadlock.c, two threads acquire locks (l1, l2) in reverse order. Therefore, it will be deadlock depending on timing -- nondeterministic.

But if you run it with dpthread, the behavior is deterministic with respect to input. For example, the following will always execute as shown in the following. 
 
{{{
$ cd test/
$ make deadlock 
$ DPTHREAD_DEBUG=0 ./deadlock -x 0 -y 0
[1] acquired l1
[1] acquired l2
[1] release  l2
[1] release  l1
[2] acquired l2
[2] acquired l1
[2] release  l1
[2] release  l2
val1 : 2
val2 : 2
}}}

If you want to disable deterministic execution, you can just comment out the following line in the source code and run make deadlock. 

{{{
// #include <dpthread-wrapper.h>
}}}